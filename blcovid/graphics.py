#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
MODULE OF GRAPHICAL TOOLS FOR BOUNDARY CLASSIFICATION.
Contains all the functions depending on a graphical library. It allows 
the use of centralized variables for graphics (save or display? format?)

Variables are first, just after imports.
Functions are sorted in alphabetic order.

 +-----------------------------------------+
 |  Date of creation: 01 Apr. 2020         |
 +-----------------------------------------+
 |  Meteo-France                           |
 |  CNRM/GMEI/LISA                         |
 +-----------------------------------------+

Copyright (C) 2019  CNRM/GMEI/LISA Thomas Rieutord

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import numpy as np
import datetime as dt
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap

from blcovid import utils


fmtImages=".png"
# Images will be saved under this format (suffix of plt.savefig)

figureDir=""
# Images will be saved in this directory (prefix of plt.savefig)

storeImages=False
# If True, figures are saved in files but not shown
# If False, figures are not saved in files but always shown

# Database of atmospheric variables long names
DicLeg = {'DD':'Wind direction (deg)','FF':'Wind Intensity (m/s)',
          'U':'Zonal Wind (m/s)','V':'Meridional Wind (m/s)', 'W':'Vertical Wind (m/s)',
          'T': 'Temperature (K) ',   'THETA':'Potential Temperature (K) ',
          'BT': 'Aerosol Backscatter (dB) ',   'SNRW':'Vertical SNR (dB) ',
          'RH' :'Relative Humidity (%)', 'PRES':'pressure (hPa) '}

# Database of unique and reproductible clusters colors
clusterMarks={0:'bo',1:'gx',2:'r^',3:'cv',4:'ys',5:'m*',6:'kp',7:'gd',8:'bx',
        9:'ro',10:'c*',11:'y+',12:'m<',13:'k,'}



def cluster2Dview(variable1,varname1,variable2,varname2,zoneID,fileName=None,
                clustersIDs=None,displayClustersIDs=False,titl=None):
    '''Plots the projection of the clusters onto the space generated by
    two predictors. It can be used to visualize clusters (boundary layer classification).
    
    [IN]
        - variable1 (np.array[N]): first variable (vector of values, regardless with their coordinates)
        - varname1 (str): standard name of first variable
        - variable2 (np.array[N]): second variable (vector of values, regardless with their coordinates)
        - varname2 (str): standard name of second variable
        - zoneID (np.array[N]): cluster labels for each point
        - fileName (str): customised file name for saving the figure
        - clustersIDs (dict): dictionary associating cluster labels to boundary layer types
                Example: {0:"CL",1:"SBL",2:"FA",3:"ML"}. Default is {0:0,1:1,...}.
        - displayClustersIDs (bool): if True, displays the clusterIDs over the graph, at the center of the cluster.
        - titl (str): customised title for the figure
        
    [OUT] 2-dimensional view of the clusters
        In X-axis is the first variable given
        In Y-axis is the second variable given
        Clusters are shown with differents colors and marks.'''
    
    if varname1 not in DicLeg.keys():
        DicLeg[varname1]=varname1
    if varname2 not in DicLeg.keys():
        DicLeg[varname2]=varname2
    
    # Number of clusters
    K=np.max(zoneID)+1
    
    if clustersIDs is None:
        clustersIDs=np.arange(K)
    else:    
        for it in clustersIDs.items():
            key,val=it
            clusterMarks[val]=clusterMarks[key]
    
    if titl is None:
        titl="Cluster in feature space | "+str(K)+" clusters"
    
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    fig=plt.figure()
    plt.title(titl)
    plt.plot(variable1,variable2,'k.')
    for k in np.unique(zoneID):
        idxk=np.where(zoneID==k)[0]
        plt.plot(variable1[idxk],variable2[idxk],clusterMarks[clustersIDs[k]],linewidth=2,label="Cluster "+str(clustersIDs[k]))
        if displayClustersIDs:
            x0text=np.mean(variable1[idxk])
            x1text=np.mean(variable2[idxk])
            plt.text(x0text,x1text,clustersIDs[k],fontweight='bold',fontsize=18)
    plt.xlabel(DicLeg[varname1])
    plt.ylabel(DicLeg[varname2])
    if storeImages:
        if fileName is None:
            fileName = "cluster2Dview_"+varname1+'-'+varname2+"_K"+str(K)
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


def cluster2Dview_manyclusters(variable1,varname1,variable2,varname2,zoneIDs,
                            titl=None,fileName=None):
    '''Plots the projection of the clusters onto the space generated by
    two predictors. It can be used to visualize clusters (boundary layer classification).
    Repeat it for 6 different numbers of clusters.
    
    [IN]
        - variable1 (np.array[N]): first variable (vector of values, regardless with their coordinates)
        - varname1 (str): standard name of first variable
        - variable2 (np.array[N]): second variable (vector of values, regardless with their coordinates)
        - varname2 (str): standard name of second variable
        - zoneIDs (list of np.array[N]): cluster labels for each point
        - titl (str): customised title for the figure
        - fileName (str): customised file name for saving the figure
        
    [OUT] 3x2 tile of 2-dimensional view of the clusters
        In X-axis is the first variable given
        In Y-axis is the second variable given
        Clusters are shown with differents colors and marks.'''
    
    if varname1 not in DicLeg.keys():
        DicLeg[varname1]=varname1
    if varname2 not in DicLeg.keys():
        DicLeg[varname2]=varname2
    
    if titl is None:
        titl="Clusters in feature space"
    
    n_kvalues = len(zoneIDs)
    nl=int(np.sqrt(n_kvalues))
    nc=int(np.ceil(n_kvalues/nl))
    
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    fig, axes = plt.subplots(nrows=nl, ncols=nc, figsize=(12, 8),sharex=True,sharey=True)
    plt.suptitle(titl)
    
    for ink in range(n_kvalues):
        zoneID = zoneIDs[ink]
        
        K=np.max(zoneID)+1
        clustersIDs=np.arange(K)
        
        plt.subplot(nl,nc,ink+1)
        plt.plot(variable1,variable2,'k.')
        for k in np.unique(zoneID):
            plt.plot(variable1[np.where(zoneID==k)],variable2[np.where(zoneID==k)],clusterMarks[clustersIDs[k]],linewidth=2,label="Cluster "+str(clustersIDs[k]))
    
        if np.mod(ink,nc)==0:
            plt.ylabel(DicLeg[varname2])
        if ink>=(nl-1)*nc:
            plt.xlabel(DicLeg[varname1])
        
    plt.tight_layout()
    if storeImages:
        if fileName is None:
            fileName="multi_cluster2Dview_"+varname1+'-'+varname2
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


def clusterZTview(t_values,z_values,zoneID,delete_mask=None,fileName=None,
            clustersIDs=None,displayClustersIDs=False,titl=None):
    '''Plots cluster labels in the same time and altitude grid where
    measurements have been done (boundary layer classification).
    
    [IN]
        - t_values (np.array[nt]): vector of time
        - z_values (np.array[nalt]): vector of altitude
        - zoneID (np.array[N]): cluster labels of each obs
        - delete_mask (np.array[nt*nalt]): mask at True when observation has been removed by the deletelines function (to avoid NaNs)
        - fileName (str): customised file name for saving the figure
        - clustersIDs (dict): dictionary associating cluster labels to boundary layer types
                Example: {0:"CL",1:"SBL",2:"FA",3:"ML"}. Default is {0:0,1:1,...}.
        - displayClustersIDs (bool): if True, displays the clusterIDs over the graph, at the center of the cluster.
        - titl (str): customised title for the figure
        
    [OUT] clusters labels on a time-altitude grid
        In X-axis is the time
        In Y-axis is the height (m agl)
        Clusters are shown with differents colors.'''
    
    
    if clustersIDs is None:
        K=np.max(zoneID)+1
        clustersIDs=np.arange(K)
    else:
        K = len(clustersIDs.items())
        for it in clustersIDs.items():
            key,val=it
            clusterMarks[val]=clusterMarks[key]
    
    if titl is None:
        titl="Cluster in time-altitude grid | "+str(K)+" clusters"
    
    clist = []
    cticks = []
    cticklabels = []
    for k in range(K):
        cticks.append(k+0.5)
        cticklabels.append(clustersIDs[k])
        clist.append(clusterMarks[clustersIDs[k]][0])
    colormap=ListedColormap(clist)
    
    # 1. Deleted labels completion (when missing data)
    if delete_mask is not None:
        fullzoneID=np.full(np.size(delete_mask),np.nan)
        fullzoneID[~delete_mask]=zoneID
    else:
        fullzoneID=zoneID
    
    # 2. Conversion datetime -> seconds
    t0=t_values[0]
    st_values = utils.dtlist2slist(t_values)
    
    # 3. Format from grid(z,t) to scatter
    TZ = utils.grid_to_scatter(st_values,z_values)
    
    # 4. Set labels at grid(z,t) format
    t_trash,z_trash,labels = utils.scatter_to_grid(TZ,fullzoneID)
    if np.max(np.abs(z_values-z_trash))+np.max(np.abs(st_values-t_trash))>1e-13:
        raise Exception("Error in z,t retrieval : max(|z_values-z_trash|)=",np.max(np.abs(z_values-z_trash)),"max(|t_values-t_trash|)=",np.max(np.abs(st_values-t_trash)))
    
    labels=np.ma.array(labels,mask=np.isnan(labels))
    
    # 5. Graphic
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    fig=plt.figure()
    plt.title(titl)
    plt.pcolormesh(t_values,z_values,labels.T,vmin=0,vmax=K,cmap=colormap)
    if displayClustersIDs:
        for k in np.unique(zoneID):
            idxk=np.where(zoneID==k)[0]
            x0text=t0+dt.timedelta(seconds=np.mean(TZ[idxk,0],axis=0))
            x1text=np.mean(TZ[idxk,1],axis=0)
            plt.text(x0text,x1text,clustersIDs[k],fontweight='bold',fontsize=18)
    cbar=plt.colorbar(label="Cluster label")
    cbar.set_ticks(cticks)
    cbar.set_ticklabels(cticklabels)
    plt.gcf().autofmt_xdate()
    plt.xlabel("Time (UTC)")
    plt.ylabel("Alt (m agl)")
    if storeImages:
        if fileName is None:
            fileName="clusterZTview_K"+str(K)
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


def clusterZTview_manyclusters(t_values,z_values,zoneIDs,delete_mask=None,
                        titl=None,fileName=None):
    '''Plots cluster labels in the same time and altitude grid where
    measurements have been done (boundary layer classification).
    Repeat it of 6 differents number of clusters.
    
    [IN]
        - t_values (np.array[nt]): vector of time
        - z_values (np.array[nalt]): vector of altitude
        - zoneIDs (list of np.array[N]): cluster labels of each obs
        - delete_mask (np.array[nt*nalt]): mask at True when observation has been removed by the deletelines function (to avoid NaNs)
        - titl (str): customised title for the figure
        - fileName (str): customised file name for saving the figure
        
    [OUT] 3x2 tile of clusters labels on a time-altitude grid
        In X-axis is the time
        In Y-axis is the height (m agl)
        Clusters are shown with differents colors.
    '''
    
    if titl is None:
        titl="Clusters in time-altitude grid"
    
    z_values=z_values/1000 		#convert meters to kilometers
    
    # 1. Conversion datetime -> seconds
    t0=t_values[0]
    st_values = utils.dtlist2slist(t_values)
    
    # 2. Format from grid(z,t) to scatter
    TZ = utils.grid_to_scatter(st_values,z_values)
    
    n_kvalues = len(zoneIDs)
    nl=int(np.sqrt(n_kvalues))
    nc=int(np.ceil(n_kvalues/nl))
    
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    fig, axes = plt.subplots(nrows=nl, ncols=nc, figsize=(12, 8),sharex=True,sharey=True)
    plt.suptitle(titl)
    for ink in range(n_kvalues):
        zoneID = zoneIDs[ink]
            
        K=np.max(zoneID)+1
        clustersIDs=np.arange(K)
        
        clist = []
        cticks = []
        cticklabels = []
        for k in np.unique(zoneID):
            cticks.append(k+0.5)
            cticklabels.append(clustersIDs[k])
            clist.append(clusterMarks[clustersIDs[k]][0])
        colormap=ListedColormap(clist)
        
        # 3. Set labels at grid(z,t) format
        t_trash,z_trash,labels = utils.scatter_to_grid(TZ,zoneID)
        if np.max(np.abs(z_values-z_trash))+np.max(np.abs(st_values-t_trash))>1e-13:
            raise Exception("Error in z,t retrieval : max(|z_values-z_trash|)=",np.max(np.abs(z_values-z_trash)),"max(|t_values-t_trash|)=",np.max(np.abs(st_values-t_trash)))
        
        labels=np.ma.array(labels,mask=np.isnan(labels))
        
        # 4. Graphic
        plt.subplot(nl,nc,ink+1)
        im=plt.pcolormesh(t_values,z_values,labels.T,vmin=0,vmax=K,cmap=colormap)
        plt.gcf().autofmt_xdate()
        
        # Colorbar
        cbar=plt.colorbar()
        cbar.set_ticks(cticks)
        cbar.set_ticklabels(cticklabels)
        
        if np.mod(ink,nc)==nl:
            cbar.set_label("Cluster labels")
        if np.mod(ink,nc)==0:
            plt.ylabel("Alt (km agl)")
        if ink>=(nl-1)*nc:
            plt.xlabel("Time (UTC)")
    
    
    fig.subplots_adjust(wspace=0,hspace=0.1)
    plt.tight_layout()
    if storeImages:
        if fileName is None:
            fileName="multi_clusterZTview"
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)


def comparisonSupervisedAlgo(X_raw,classifiers,resolution=50):
    '''Compare several supervised algorithms by display the border of
    the class attribution behind the actual data points.
    
    [IN]
        - X_raw (np.array[N,p]): matrix of data points (one column for each predictor, only the two first are used)
        - classifiers (list of sklearn object with "predict" method): list trained classifiers to test
        - resolution (int): number of points in each coordinates for the evaluation grid.
                The higher, the more precise is the border.
        
    [OUT] Tile of plot similar to cluster2Dview with the classification
        border in color shades in background.
    '''
    
    
    print("Prepare comparison graphics...")
    classifiers_keys =[str(clf).split('(')[0] for clf in classifiers]
    
    BTminbound=X_raw[:,0].min()-1
    BTmaxbound=X_raw[:,0].max()+1
    Tminbound=X_raw[:,1].min()-2
    Tmaxbound=X_raw[:,1].max()+2
    
    
    T_values=np.linspace(Tminbound,Tmaxbound,resolution)
    BT_values=np.linspace(BTminbound,BTmaxbound,resolution)
    
    X_pred = utils.grid_to_scatter(BT_values,T_values)
    
    
    fig, axs = plt.subplots(1,len(classifiers),figsize=(18,6))
    plt.tight_layout()
    for icl in range(len(classifiers)):
        clf = classifiers[icl]
        print("Classifier",icl,"/",len(classifiers),classifiers_keys[icl])
        y_pred=clf.predict(X_pred)
        b,t,y=utils.scatter_to_grid(X_pred,y_pred)
        
        axs[icl].set_title(classifiers_keys[icl])
        axs[icl].pcolormesh(BT_values,T_values,y.T,vmin=-0.5,cmap='nipy_spectral')
        
        axs[icl].plot(X_raw[:,0],X_raw[:,1],'k.')
        axs[icl].set_xlabel(DicLeg['BT'])
        axs[icl].set_ylabel(DicLeg['T'])
    
    if storeImages:
        fileName = "compSupervisedAlgo"
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)


def estimator_quality(accuracies,chronos,estimator_names,titl=None):
    '''Display score versus computation time for a series of estimators.
    Best estimators are in the bottom-right corner.
    
    Abcissa is the R2-score (1-mse/variance: the higher, the better)
    Ordinate is the computing time.
    Both are recorded for Ne estimators and Nr random split of testing
    and training sets.
    
    [IN]
        - accuracies (np.array[Ne,Nr]): R2-score for all estimators and random split
        - chronos (np.array[Ne,Nr]): computing time for all estimators and random split
        - estimator_names (list[Ne] of str): names of the estimators
        - titl (str): if provided, change the title of the figure
    
    [OUT] figure
    '''
    
    if titl is None:
        titl="Performance/speed comparison of estimators"
    
    plt.figure(figsize=(8,8))
    plt.title(titl)
    for icl in range(len(estimator_names)):
        xtext=np.mean(accuracies[icl,:])
        ytext=np.mean(chronos[icl,:])
        plt.scatter(accuracies[icl,:],chronos[icl,:],alpha=0.8,label=estimator_names[icl])
        plt.text(xtext,ytext,estimator_names[icl],fontweight='bold')
    plt.grid()
    plt.xlabel("R2-score")
    plt.ylabel("Comp. time")
    plt.legend(loc='best')
    if storeImages:
        fileName="estimator_quality"
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)


def internal_quality_map(xscore,yscore,score_names,estimator_names,k_names=None,titl=None):
    '''Display internal quality score (quality score not relying on
    external reference) for several algorithms and number of clusters.
    Best estimators are in the bottom-right corner.
    
    [IN]
        - xscore (np.array[Ne,Nk]): internal score on the x-axis
        - yscore (np.array[Ne,Nk]): internal score on the y-axis
        - estimator_names (list[Ne] of str): names of the estimators
        - estimator_names (np.array[Nk]): number of clusters
        - titl (str): if provided, change the title of the figure
    
    [OUT] figure
    '''
    
    if xscore.shape != yscore.shape:
        raise ValueError("Internal scores must have the same shape")
    
    if titl is None:
        titl="Internal scores comparison of estimators"
        
    if k_names is None:
        k_names = np.arange(xscore.shape[1])+2
    
    plt.figure(figsize=(8,8))
    plt.title(titl)
    for icl in range(len(estimator_names)):
        plt.plot(xscore[icl,:],yscore[icl,:],'-o',alpha=0.8,label=estimator_names[icl])
        for ik in range(len(k_names)):
            plt.text(xscore[icl,ik],yscore[icl,ik],k_names[ik])
        
    plt.grid()
    plt.xlabel(score_names[0])
    plt.ylabel(score_names[1])
    plt.legend(loc='best')
    if storeImages:
        fileName="internal_quality_map"
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)


def plot_dendrogram(linkageMatrix,algoParams):
    '''Plot the dendrogram (hierarchical clustering)
    
    [IN]
        - linkageMatrix (np.array): output of the function scipy.cluster.hierarchy.linkage
        - algoParams (str): clustering paramaters (metric and linkage)
    
    [OUT] Dendrogram: merging tree of groups in hierarchical classification.
    Each horizontal lines correspond to the merging of two subgroups.
    X-axis: individuals (or very small groups)
    Y-axis: dissimilarity between groups that are merged
    '''
    
    from scipy.cluster import hierarchy as hc
    
    plt.figure()
    plt.title(u"Dendrogram | "+algoParams.upper())
    hc.dendrogram(linkageMatrix,p=10,truncate_mode='level',distance_sort='ascending',no_labels=True)
    plt.ylabel("Cophenetic distance")
    plt.xlabel("Observations")
    if storeImages:
        plt.savefig(figureDir+"dendrogram_"+algoParams+fmtImages)
        plt.close()
    else:
        plt.show(block=False)


def quicklook(originaldatapath,altmax=4000):
    '''Quick look at the original data.
    
    [IN]
        - originaldatapath (str): path to the data file (netCDF)
        - altmax (float): top altitude of the graph
    
    [OUT] Display the default variable of the given file against time
    and altitude.
        In X-axis is the time
        In Y-axis is the height (m agl)
        Variable values are in shades of colors.
    '''
    t,z,V=utils.extractOrigData(originaldatapath,altmax=altmax)
    instru=utils.instrumentkind(originaldatapath)
    
    if instru=='hatpro':
        titl="Original temperature | "+instru.upper()+" | "+t[0].strftime("%Y/%m/%d")
        valmin=260
        valmax=285
        colormp='jet'
        clabl="Temperature (K)"
        fileName="T_orig_"+t[0].strftime("%Y%m%d")
    else:
        titl="Original backscatter | "+instru.upper()+" | "+t[0].strftime("%Y/%m/%d")
        valmin=-11
        valmax=20
        colormp='plasma'
        clabl="Aerosol Backscatter (dB)"
        fileName="BT_orig_"+t[0].strftime("%Y%m%d")
        # Negative backscatter are outliers
        with np.errstate(invalid='ignore'):
            V[V<=0]=np.nan
            V=10*np.log10(V)
    
    
    plt.figure()
    plt.title(titl)
    plt.pcolormesh(t,z,V.T,vmin=valmin,vmax=valmax,cmap=colormp)
    plt.colorbar(label=clabl)
    plt.gcf().autofmt_xdate()
    plt.xlabel("Time (UTC)")
    plt.ylabel("Alt (m agl)")
    if storeImages:
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
    else:
        plt.show(block=False)
   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def scores_manyclusters(K_values,score_list,score_names):
    '''Plot the classification scores against the number of clusters.
    
    [IN]
        - K_values (np.array[Nk]): array of number of clusters
        - score_list (list of np.array[Nk]): list of scores arrays corresponding the different number of cluster values
        - score_names (list of str): list of scores names
    
    [OUT] Vertically-stacked figures sharing X-axis which the number of clusters.
    Each subfigure as one the score as Y-axis.
    Optimal values of the scores are highlighted by yellow squares.
    '''
    
    fig, axs = plt.subplots(len(score_list), sharex=True, gridspec_kw={'hspace': 0})
    fig.suptitle("Optimal n_clusters acc.t. several scores")
    for s in range(len(score_list)):
        axs[s].plot(K_values,score_list[s])
        axs[s].set_ylabel(score_names[s])
        axs[s].set_xlabel("Number of clusters")
        if score_names[s]=='Davies-Bouldin':
            kbest=np.argmin(score_list[s])
        else:
            kbest=np.argmax(score_list[s])
        axs[s].plot(K_values[kbest],score_list[s][kbest],'ys')
        axs[s].xaxis.grid()
        
    # Hide x labels and tick labels for all but bottom plot.
    # Source (2020/04/02): https://matplotlib.org/3.1.0/gallery/subplots_axes_and_figures/subplots_demo.html
    for ax in axs:
        ax.label_outer()
    
    if storeImages:
        fileName="classifScores"
        plt.savefig(figureDir+fileName+fmtImages)
        plt.close()
        print("Figure saved:",figureDir+fileName+fmtImages)
    else:
        plt.show(block=False)


########################
#      TEST BENCH      #
########################
# Launch with
# >> python graphics.py
#
# For interactive mode
# >> python -i graphics.py
#
if __name__ == '__main__':
    
    dataDir = "0-original-data/training-data/"
    CEI_file = "PASSY_PASSY_CNRM_CEILOMETER_CT25K_2015_0219_V01.nc"
    MWR_file = "PASSY2015_SALLANCHES_CNRM_MWR_HATPRO_2015_0219_V01.nc"
    
    # Test of quicklook
    #------------------------
    print("\n --------------- Test of quicklook")
    quicklook(dataDir+CEI_file)
    quicklook(dataDir+MWR_file)
    
    
    input("\n Press Enter to exit (close down all figures)\n")
