#!/usr/bin/env python
# coding: utf-8
"""
MODULE FOR PREDICTING BOUNDARY LAYER CLASSIFICATION FROM SUPERVISED MODELS
Perform supervised boundary layer classification on prepared datasets thanks
to previously trained classifiers. Take in input the dataset generated by
`prepdataset.py` and the pre-trained models generated by `supervisedfit.py`.

Functions are sorted in complexity order:
    - check_prepkey
    - predict_sblc

 +-----------------------------------------+
 |  Date of creation: 06 Apr. 2020         |
 +-----------------------------------------+
 |  Meteo-France                           |
 |  CNRM/GMEI/LISA                         |
 +-----------------------------------------+
"""

# ### Load packages

import os
import numpy as np
import datetime as dt
import pickle
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import pairwise_distances

from blcovid import utils
from blcovid import graphics


def check_prepkey(datasetpath, classifierpath, raise_error=True):
    """Check consistency between the preparation of the dataset and the
    chosen classifier. If they are not consistent, the model will not be
    able to perform the classification.
    
    
    Parameters
    ----------
    datasetpath: str
        Path where is located the dataset (.nc)
    
    classifierpath: str
        Path where is located the classifier (.pkl)
    
    raise_error: bool, default=True
        If True, raise a ValueError if the classifier and the dataset don't match
    
    
    Returns
    -------
    is_consistent: bool
        If True, dataset and classifier are compatible
    
    
    Examples
    --------
    >>> from blcovid.supervisedpred import check_prepkey
    >>> datasetname = "DATASET_2015_0219.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.nc"
    >>> goodClassifier = "LabelSpreading.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.pkl"
    >>> badClassifier = "LabelSpreading.PASSY2023_BT-T_linear_dz447_dt0_zmax2577.pkl"
    >>> check_prepkey(datasetname, goodClassifier)
    True
    >>> check_prepkey(datasetname, badClassifier)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "../blcovid/supervisedpred.py", line 78, in check_prepkey
        raise ValueError("Preparation of dataset inconsistent with chosen classifier")
    ValueError: Preparation of dataset inconsistent with chosen classifier
    >>> check_prepkey(datasetname, badClassifier, raise_error=False)
    False
    """

    datasetname = os.path.split(datasetpath)[-1]
    classifiername = os.path.split(classifierpath)[-1]

    is_consistent = datasetname.split(".")[1] == classifiername.split(".")[1]
    if raise_error and not is_consistent:
        raise ValueError("Preparation of dataset inconsistent with chosen classifier")

    return is_consistent


def predict_sblc(datasetpath, classifierpath, plot_on=True):
    """Perform supervised classification of prepared data according to
    pre-trained classifiers.
    
    
    Parameters
    ----------
    datasetpath: str
        Path where is located the dataset (.nc)
    
    classifierpath: str
        Path where is located the classifier (.pkl)
    
    plot_on: bool, default=True
        If False, all graphics are disabled
    
    
    Returns
    -------
    rawlabl: ndarray of shape (N,), dtype=int
        Predicted cluster labels for the given dataset
    
    labelid: dict
        Correspondance between cluster labels and boundary layer types
    
    
    Examples
    --------
    >>> from blcovid.supervisedpred import predict_sblc
    >>> dataDir = "../working-directories/1-unlabelled-datasets/"
    >>> classifierDir = "../working-directories/4-pre-trained-classifiers/"
    >>> datasetname = "DATASET_2015_0219.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.nc"
    >>> classifierName = "LabelSpreading.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.pkl"
    >>> labels, labelids = predict_sblc(dataDir + datasetname, classifierDir + classifierName)
    >>> labels
    array([1, 1, 1, ..., 3, 3, 3], dtype=int32)
    >>> labelids
    {0: 'CL', 1: 'SBL', 2: 'ML', 3: 'FA'}
    """

    # Loadings
    # ------------

    # ### Load prepared data

    X_raw, t_common, z_common = utils.load_dataset(
        datasetpath, variables_to_load=["X_raw", "time", "altitude"]
    )

    if np.isnan(X_raw).sum() > 0:
        print("WARNING:", np.isnan(X_raw).sum(), "NaN in the input dataset")

    # ### Load pre-trained classifier

    # Check if consistent with dataset
    check_prepkey(datasetpath, classifierpath, raise_error=True)

    fc = open(classifierpath, "rb")
    clf = pickle.load(fc)
    labelid = eval(clf.label_identification_)

    # Perform classification
    # -------------------

    # ### Normalization
    scaler = clf.scaler
    X = scaler.transform(X_raw)
    
    # ### Just predict from the loaded classifier

    rawlabl = clf.predict(X)

    # ### Visualize the results
    if plot_on:
        datasetname = datasetpath.split("/")[-1]
        prefx, prepkey, dotnc = datasetname.split(".")
        prepParams = utils.load_preparation_params(datasetname)
        predictors = prepParams[0]

        graphics.cluster2Dview(
            X_raw[:, 0],
            predictors[0],
            X_raw[:, 1],
            predictors[1],
            rawlabl,
            clustersIDs=labelid,
            displayClustersIDs=True,
            fileName="SBLC_featureSpace_" + prefx[-9:],
        )
        graphics.clusterZTview(
            t_common,
            z_common,
            rawlabl,
            clustersIDs=labelid,
            displayClustersIDs=True,
            fileName="SBLC_timeAlti_" + prefx[-9:],
        )

    return rawlabl, labelid

def sblc_evaluation(datasetpath, classifierpath, plot_on=False):
    """Perform supervised classification of prepared data according to
    pre-trained classifiers and assess the agreement with the training set.
    
    
    Parameters
    ----------
    datasetpath: str
        Path where is located the dataset (.nc)
    
    classifierpath: str
        Path where is located the classifier (.pkl)
    
    plot_on: bool, default=False
        If False, all graphics are disabled
    
    
    Returns
    -------
    bltype_agreement: dict
        Level of agreement with the training set for all boundary layer types
    
    
    Examples
    --------
    >>> from blcovid.supervisedpred import sblc_evaluation
    >>> dataDir = "../working-directories/1-unlabelled-datasets/"
    >>> classifierDir = "../working-directories/4-pre-trained-classifiers/"
    >>> datasetname = "DATASET_2015_0219.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.nc"
    >>> classifierName = "LabelSpreading.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.pkl"
    >>> classifierName = "KNeighborsClassifier.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.pkl"
    >>> avgprb, labelid = sblc_evaluation(dataDir + datasetname, classifierDir + classifierName)
    >>> avgprb
    array([0.95228895, 0.98532755, 0.98565797, 0.99357377])
    >>> labelid
    {0: 'CL', 1: 'SBL', 2: 'ML', 3: 'FA'}
    """

    # Loadings
    # ------------

    # ### Load prepared data

    X_raw, t_common, z_common = utils.load_dataset(
        datasetpath, variables_to_load=["X_raw", "time", "altitude"]
    )

    if np.isnan(X_raw).sum() > 0:
        print("WARNING:", np.isnan(X_raw).sum(), "NaN in the input dataset")

    # ### Load pre-trained classifier

    # Check if consistent with dataset
    check_prepkey(datasetpath, classifierpath, raise_error=True)

    fc = open(classifierpath, "rb")
    clf = pickle.load(fc)
    labelid = eval(clf.label_identification_)

    # Perform classification
    # -------------------

    # ### Normalization
    scaler = clf.scaler
    X = scaler.transform(X_raw)
    # X = X_raw
    
    # ### Just predict from the loaded classifier
    
    rawlabl = clf.predict(X)
    
    
    # ### Visualize the results
    
    if plot_on:
        datasetname = datasetpath.split("/")[-1]
        prefx, prepkey, dotnc = datasetname.split(".")
        prepParams = utils.load_preparation_params(datasetname)
        predictors = prepParams[0]

        graphics.cluster2Dview(
            X_raw[:, 0],
            predictors[0],
            X_raw[:, 1],
            predictors[1],
            rawlabl,
            clustersIDs=labelid,
            displayClustersIDs=True,
            fileName="SBLC_featureSpace_" + prefx[-9:],
        )
        graphics.clusterZTview(
            t_common,
            z_common,
            rawlabl,
            clustersIDs=labelid,
            displayClustersIDs=True,
            fileName="SBLC_timeAlti_" + prefx[-9:],
        )

    # Evaluate the classes probabilities
    # -------------------
    prb = clf.predict_proba(X_raw)
    avgprb = np.mean(prb,axis=0)
    
    # Evaluate the mean distance to training set cluster centers
    # -------------------
    md2traincc = np.zeros(clf.classes_.size)
    traincc = clf.training_class_centroids_
    pwd2traincc = pairwise_distances(X,traincc)
    for k in range(clf.classes_.size):
        idx=np.where(rawlabl==k)[0]
        if idx.size>0:
            md2traincc[k] = np.nanmean(pwd2traincc[idx,:], axis=0)[k]
        else: # RuntimeWarning: Mean of empty slice
            md2traincc[k] = np.nan
    
    
    return md2traincc, avgprb, labelid

########################
#      TEST BENCH      #
########################
# Launch with
# >> python supervisedpred.py
#
# For interactive mode
# >> python -i supervisedpred.py
#
if __name__ == "__main__":

    dataDir = "../working-directories/1-unlabelled-datasets/"
    datasetname = "DATASET_2015_0219.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.nc"

    classifierDir = "../working-directories/4-pre-trained-classifiers/"
    classifierName = "LabelSpreading.PASSY2015_BT-T_linear_dz40_dt30_zmax2000.pkl"
    inconsistentClassifierName = (
        "LabelSpreading.PASSY2023_BT-T_linear_dz447_dt0_zmax2577.pkl"
    )

    graphics.storeImages = True
    graphics.figureDir = "../working-directories/5-output-trainingday/"

    # Test of check_prepkey
    # ------------------------
    print("\n --------------- Test of check_prepkey")
    isConsistent = check_prepkey(
        dataDir + datasetname,
        classifierDir + inconsistentClassifierName,
        raise_error=False,
    )
    print("Is consistent?", isConsistent, "(must be False)")
    isConsistent = check_prepkey(
        dataDir + datasetname, classifierDir + classifierName, raise_error=False
    )
    print("Is consistent?", isConsistent, "(must be True)")

    # Test of predict_sblc
    # ------------------------
    print("\n --------------- Test of predict_sblc")
    predict_sblc(dataDir + datasetname, classifierDir + classifierName)
